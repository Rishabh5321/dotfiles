# .github/workflows/flake_build.yml
name: flake_build

on:
  push:
  pull_request:
  workflow_dispatch:

jobs:
  build-configurations:
    name: Build NixOS Configurations
    runs-on: ubuntu-latest
    permissions: # Optional: Define minimal permissions
      contents: read
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Install Nix
        uses: cachix/install-nix-action@v31
        with:
          install_url: https://nixos.org/nix/install
          extra_nix_config: |
            auto-optimise-store = true
            experimental-features = nix-command flakes
            download-buffer-size = 500000000 # Consider if this large buffer is strictly necessary

      - name: Setup Cachix
        uses: cachix/cachix-action@v16
        if: github.event_name == 'push' && github.ref == 'refs/heads/main' 
        with:
          name: pkgss # Replace with your actual cache name
          authToken: "${{ secrets.CACHIX_AUTH_TOKEN }}"

      - name: Check Dell Configuration
        id: build_dell
        run: |
          log_file="build_dell.log"
          filtered_log_file="build_dell_filtered.log"
          echo "::group::Running Nix dry-run for Dell"
          # Run nix build, capture all output, add trace on error
          if nix build .#nixosConfigurations.dell.config.system.build.toplevel --dry-run --show-trace > "$log_file" 2>&1; then
            echo "status=passed" >> $GITHUB_OUTPUT
            echo "log_path=$filtered_log_file" >> $GITHUB_OUTPUT
            echo "Dell configuration check completed successfully." > "$filtered_log_file" # Keep file for consistency
            echo "::notice file=$log_file::Dell build dry-run successful."
          else
            # Build failed
            echo "status=failed" >> $GITHUB_OUTPUT
            echo "log_path=$filtered_log_file" >> $GITHUB_OUTPUT
            # Extract relevant lines: try errors/warnings first, fallback to tail, limit lines
            {
              echo "Dell check failed. Relevant log lines:"
              grep -E '(error:|warning:)' "$log_file" || tail -n 20 "$log_file"
            } | head -n 30 > "$filtered_log_file" # Limit total output for notification
            echo "::error file=$log_file::Dell build dry-run failed. Check logs."
          fi
          echo "::endgroup::"
          echo "--- Filtered Log Snippet (Dell) ---"
          cat "$filtered_log_file"
          echo "--- End Filtered Log Snippet ---"


      - name: Check Redmi Configuration
        id: build_redmi
        # Use always() to ensure this runs even if the Dell check fails
        if: always()
        run: |
          log_file="build_redmi.log"
          filtered_log_file="build_redmi_filtered.log"
          echo "::group::Running Nix dry-run for Redmi"
          if nix build .#nixosConfigurations.redmi.config.system.build.toplevel --dry-run --show-trace > "$log_file" 2>&1; then
            echo "status=passed" >> $GITHUB_OUTPUT
            echo "log_path=$filtered_log_file" >> $GITHUB_OUTPUT
            echo "Redmi configuration check completed successfully." > "$filtered_log_file"
            echo "::notice file=$log_file::Redmi build dry-run successful."
          else
            echo "status=failed" >> $GITHUB_OUTPUT
            echo "log_path=$filtered_log_file" >> $GITHUB_OUTPUT
            {
              echo "Redmi check failed. Relevant log lines:"
              grep -E '(error:|warning:)' "$log_file" || tail -n 20 "$log_file"
            } | head -n 30 > "$filtered_log_file"
            echo "::error file=$log_file::Redmi build dry-run failed. Check logs."
          fi
          echo "::endgroup::"
          echo "--- Filtered Log Snippet (Redmi) ---"
          cat "$filtered_log_file"
          echo "--- End Filtered Log Snippet ---"

      - name: Generate Job Summary
        # Use always() to ensure summary is generated even on partial failure
        if: always()
        run: |
          echo "## NixOS Configuration Build Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Dell Configuration:** ${{ steps.build_dell.outputs.status }}" >> $GITHUB_STEP_SUMMARY
          if [[ "${{ steps.build_dell.outputs.status }}" == "failed" ]]; then
            echo "<details><summary>Dell Log Snippet</summary>" >> $GITHUB_STEP_SUMMARY
            echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
            # Use html escaping for safety inside summary markdown
            cat "${{ steps.build_dell.outputs.log_path }}" | sed 's/&/\&amp;/g; s/</\&lt;/g; s/>/\&gt;/g;' >> $GITHUB_STEP_SUMMARY
            echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
            echo "</details>" >> $GITHUB_STEP_SUMMARY
          fi
          echo "- **Redmi Configuration:** ${{ steps.build_redmi.outputs.status }}" >> $GITHUB_STEP_SUMMARY
          if [[ "${{ steps.build_redmi.outputs.status }}" == "failed" ]]; then
            echo "<details><summary>Redmi Log Snippet</summary>" >> $GITHUB_STEP_SUMMARY
            echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
            cat "${{ steps.build_redmi.outputs.log_path }}" | sed 's/&/\&amp;/g; s/</\&lt;/g; s/>/\&gt;/g;' >> $GITHUB_STEP_SUMMARY
            echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
            echo "</details>" >> $GITHUB_STEP_SUMMARY
          fi
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "*Check workflow run logs for full details.*" >> $GITHUB_STEP_SUMMARY

      # Option 2: Cleaner Bash Script for Telegram Notification
      - name: Send Telegram Notification (Cleaner Bash)
        if: always()
        env:
          TELEGRAM_TOKEN: ${{ secrets.TELEGRAM_TOKEN }}
          CHAT_ID: ${{ secrets.CHAT_ID }}
          DELL_STATUS: ${{ steps.build_dell.outputs.status }}
          REDMI_STATUS: ${{ steps.build_redmi.outputs.status }}
          DELL_LOG_PATH: ${{ steps.build_dell.outputs.log_path }}
          REDMI_LOG_PATH: ${{ steps.build_redmi.outputs.log_path }}
          BRANCH_NAME: ${{ github.ref_name }}
          REPO_NAME: ${{ github.repository }}
          RUN_URL: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
        run: |
          # Determine overall status and emoji
          if [[ "$DELL_STATUS" == "passed" && "$REDMI_STATUS" == "passed" ]]; then
            STATUS_ICON="✅"
            STATUS_TEXT="Passed"
          else
            STATUS_ICON="❌"
            STATUS_TEXT="Failed"
          fi

          # --- Build Plain Text Message using printf for newlines ---
          MESSAGE_PLAIN="" # Start with empty

          # Basic Status Line (printf handles \n correctly)
          printf -v MESSAGE_PLAIN " %s NixOS checks for *%s* (%s) *%s*\n" "$STATUS_ICON" "$REPO_NAME" "$BRANCH_NAME" "$STATUS_TEXT"

          # Add a blank line (printf handles \n)
          printf -v MESSAGE_PLAIN "%s\n" "$MESSAGE_PLAIN"

          # Detailed Status (printf handles \n)
          printf -v MESSAGE_PLAIN "%sDell Config: \`%s\`\n" "$MESSAGE_PLAIN" "$DELL_STATUS"
          printf -v MESSAGE_PLAIN "%sRedmi Config: \`%s\`\n" "$MESSAGE_PLAIN" "$REDMI_STATUS"

          # Function to read and format log snippet (plain text) - remains the same
          format_log_plain() {
            local log_path="$1"
            local max_lines=15 # Limit lines for Telegram
            local output=""
            if [[ -s "$log_path" ]]; then
              output=$(awk '{print NR". "$0}' "$log_path" | head -n $max_lines | sed 's/`/\\`/g; s/\x0/\\0/g')
            fi
            echo "$output"
          }

          # Dell Issues (printf handles \n)
          if [[ "$DELL_STATUS" == "failed" ]]; then
            LOG_SNIPPET=$(format_log_plain "$DELL_LOG_PATH")
            if [[ -n "$LOG_SNIPPET" ]]; then
              printf -v MESSAGE_PLAIN "%s\n*Dell Issues:*\n" "$MESSAGE_PLAIN" # Add section header
              printf -v MESSAGE_PLAIN "%s\`\`\`\n%s\n\`\`\`\n" "$MESSAGE_PLAIN" "$LOG_SNIPPET" # Add code block
            fi
          fi

          # Redmi Issues (printf handles \n)
          if [[ "$REDMI_STATUS" == "failed" ]]; then
            LOG_SNIPPET=$(format_log_plain "$REDMI_LOG_PATH")
            if [[ -n "$LOG_SNIPPET" ]]; then
              printf -v MESSAGE_PLAIN "%s\n*Redmi Issues:*\n" "$MESSAGE_PLAIN" # Add section header
              printf -v MESSAGE_PLAIN "%s\`\`\`\n%s\n\`\`\`\n" "$MESSAGE_PLAIN" "$LOG_SNIPPET" # Add code block
            fi
          fi

          # Link and Timestamp (printf handles \n)
          CURRENT_TIME_IST=$(TZ='Asia/Kolkata' date '+%Y-%m-%d %H:%M:%S %Z')
          printf -v MESSAGE_PLAIN "%s\n[View Workflow Run](%s)\n" "$MESSAGE_PLAIN" "$RUN_URL" # Add link
          printf -v MESSAGE_PLAIN "%sGenerated on %s" "$MESSAGE_PLAIN" "$CURRENT_TIME_IST" # Add timestamp (no final newline needed)

          # --- URL-encode the entire message ONCE ---
          MESSAGE_BODY_ENCODED=$(printf "%s" "$MESSAGE_PLAIN" | jq -sRr @uri)


          # --- Send notification ---
          echo "Sending Telegram Notification..."
          curl -s --fail -X POST "https://api.telegram.org/bot${TELEGRAM_TOKEN}/sendMessage" \
            --data "chat_id=${CHAT_ID}" \
            --data "text=${MESSAGE_BODY_ENCODED}" \
            -d "parse_mode=Markdown" \
            -d "disable_web_page_preview=true"

          CURL_EXIT_CODE=$?
          if [[ $CURL_EXIT_CODE -ne 0 ]]; then
              echo "::error::Failed to send Telegram notification. Curl exit code: $CURL_EXIT_CODE"
              # echo "::debug::Plain message before encoding: $MESSAGE_PLAIN" # Uncomment for debugging
              exit 1
          else
              echo "Telegram notification sent successfully."
          fi